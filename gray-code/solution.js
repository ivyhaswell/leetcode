/* https://leetcode-cn.com/problems/gray-code/ */
/**
 * 思路其实是这样，从1开始找规律
 * 1位有2个:
 * 0, 1
 * 2位有4个:
 * 00,01,11,10
 * 3位有8个:
 * 000,001,011,010,110,111,101,100
 * 
 * 其实对于n位来说，排列的状态就是n-1位的状态在前面加了一个位数的状态：0和1
 * 那么从n-1到n，设n-1的格雷码是G1，复制一份作为G2，只需要在G1的前面加0，在G2的前面加1，就
 * 是n位的所有格雷码，但这里的问题是G1末尾到G2开头并不衔接，那么需要做的操作就是将G2反转过来，
 * 因为G1的开头到结尾变化连续，而G2是G1的copy，所以G2的结尾到开头也变化连续，而G2的结尾和G1
 * 的结尾是一样的，反转后拼接上去就是正好后面的位数相等，只有第一位是从0到1的变化，完美衔接。
 * 
 * 拿n=3举例:
 * 1位是:
 * [0, 1]
 * 复制一份，分别在开头拼上0和1，得到:
 * [00,01] 和 [10,11]
 * 将第二个数组反转拼接上去，得到了n=2时的数组:
 * [00,01,11,10]
 * 同样的步骤，复制一份，分别在开头拼上0和1，得到:
 * [000,001,011,010] 和 [100,101,111,110]
 * 将第二个数组反转拼接上去，就得到了n=3时的数组:
 * [000,001,011,010,110,111,101,100]
 * 
 * @param {number} n
 * @return {number[]}
 */
var grayCode = function (n) {
    if (n === 0) { return [0] }

    let res = ['0', '1']

    function grow() {
        let len = res.length
        res = res.concat(res.slice(0).reverse())
        res = res.map((item, index) => item = index < len ? '0' + item : '1' + item)
    }

    for (let i = 1; i < n; i++) {
        grow()
    }
    return res.map(i => parseInt(i, 2))
};

export { grayCode }